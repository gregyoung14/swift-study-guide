# Memory Management (ARC, Ownership)

## Overview
This section provides a deep dive into memory management in Swift, focusing on Automatic Reference Counting (ARC) and the concepts of strong, weak, and unowned references. Understanding how Swift manages memory is crucial for building performant and stable iOS applications, preventing memory leaks, and ensuring efficient resource utilization.

## Table of Contents

- [Introduction to Memory Management](#introduction-to-memory-management)
    - [The Role of Memory in Applications (Performance, Stability)](#the-role-of-memory-in-applications-performance-stability)
    - [Why Manual Memory Management is Hard](#why-manual-memory-management-is-hard)
    - [Memory Areas (Stack, Heap, Static, Code)](#memory-areas-stack-heap-static-code)
- [Automatic Reference Counting (ARC)](#automatic-reference-counting-arc)
    - [How ARC Works (Reference Counts)](#how-arc-works-reference-counts)
    - [Reference Counting in Action (Allocation, Deallocation)](#reference-counting-in-action-allocation-deallocation)
    - [Strong References (Default Behavior)](#strong-references-default-behavior)
- [Strong Reference Cycles](#strong-reference-cycles)
    - [The Problem of Strong Reference Cycles (Memory Leaks)](#the-problem-of-strong-reference-cycles-memory-leaks)
    - [Examples of Strong Reference Cycles (Class Instances, Closures)](#examples-of-strong-reference-cycles-class-instances-closures)
- [Resolving Strong Reference Cycles](#resolving-strong-reference-cycles)
    - [Weak References (`weak` keyword)](#weak-references-weak-keyword)
        - [When to Use Weak References (Parent-Child, Delegates)](#when-to-use-weak-references-parent-child-delegates)
        - [Weak References and Optionals (`weak var myDelegate: SomeDelegate?`)](#weak-references-and-optionals-weak-var-mydelegate-somedelegate)
    - [Unowned References (`unowned` keyword)](#unowned-references-unowned-keyword)
        - [When to Use Unowned References (Guaranteed Lifetime)](#when-to-use-unowned-references-guaranteed-lifetime)
        - [Unowned References and Implicitly Unwrapped Optionals](#unowned-references-and-implicitly-unwrapped-optionals)
    - [Choosing Between Weak and Unowned](#choosing-between-weak-and-unowned)
- [Capture Lists in Closures](#capture-lists-in-closures)
    - [Defining a Capture List (`[weak self]`, `[unowned self]`, `[a, b]`)](#defining-a-capture-list-weak-self-unowned-self-a-b)
    - [Weak and Unowned in Capture Lists](#weak-and-unowned-in-capture-lists)
    - [Unowned Optional References in Capture Lists](#unowned-optional-references-in-capture-lists)
    - [Implicit vs. Explicit Capture](#implicit-vs-explicit-capture)
- [Memory Leaks and Debugging](#memory-leaks-and-debugging)
    - [Identifying Memory Leaks with Xcode Instruments (Leaks Tool)](#identifying-memory-leaks-with-xcode-instruments-leaks-tool)
    - [Common Causes of Memory Leaks (Delegates, Closures, KVO)](#common-causes-of-memory-leaks-delegates-closures-kvo)
    - [Debugging Strong Reference Cycles](#debugging-strong-reference-cycles)
- [Value Types and Memory](#value-types-and-memory)
    - [Stack vs. Heap Allocation (Performance Implications)](#stack-vs-heap-allocation-performance-implications)
    - [Copy-on-Write Behavior (e.g., Arrays, Dictionaries, Strings - Efficiency)](#copy-on-write-behavior-eg-arrays-dictionaries-strings-efficiency)
    - [When to Choose Structs over Classes for Memory Efficiency](#when-to-choose-structs-over-classes-for-memory-efficiency)
